// Generated by CoffeeScript 1.9.2
(function() {
  var hasProp = {}.hasOwnProperty;

  define(['underscore'], function(_) {
    var BEATS_PER_MEASURE, BEAT_DURATION, MEASURE_DURATION, Sequencer, audioContext, beatListener, customBeatListener, doScheduling, isRunning, samples;
    BEATS_PER_MEASURE = 16;
    MEASURE_DURATION = 4;
    BEAT_DURATION = MEASURE_DURATION / BEATS_PER_MEASURE;
    audioContext = new window.AudioContext();
    isRunning = false;
    samples = {};
    customBeatListener = null;
    beatListener = function(beatIndex, beatTime) {
      var name, nextBeatIndex, nextBeatTime, node, sample;
      nextBeatTime = beatTime + BEAT_DURATION;
      nextBeatIndex = (beatIndex + 1) % BEATS_PER_MEASURE;
      for (name in samples) {
        if (!hasProp.call(samples, name)) continue;
        sample = samples[name];
        if (sample.schedule[nextBeatIndex] === 1) {
          node = audioContext.createBufferSource();
          node.buffer = sample.buffer;
          node.connect(sample.destination);
          node.start(nextBeatTime);
        }
      }
      if (customBeatListener != null) {
        return customBeatListener(beatIndex);
      }
    };
    doScheduling = (function() {
      var nextMeasureStart;
      nextMeasureStart = audioContext.currentTime + MEASURE_DURATION;
      return function() {
        var beatIndex, beatTime, beatTimes, currentTime, fn, i, j, len;
        currentTime = audioContext.currentTime;
        if (currentTime + MEASURE_DURATION <= nextMeasureStart) {
          return;
        }
        beatTimes = (function() {
          var j, ref, results;
          results = [];
          for (i = j = 0, ref = BEATS_PER_MEASURE; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results.push(nextMeasureStart + i * BEAT_DURATION);
          }
          return results;
        })();
        fn = function(beatIndex, beatTime) {
          return setTimeout(function() {
            return beatListener(beatIndex, beatTime);
          }, (beatTime - currentTime) * 1000);
        };
        for (beatIndex = j = 0, len = beatTimes.length; j < len; beatIndex = ++j) {
          beatTime = beatTimes[beatIndex];
          fn(beatIndex, beatTime);
        }
        return nextMeasureStart += MEASURE_DURATION;
      };
    })();
    Sequencer = {
      addSample: function(sampleName, buffer, schedule) {
        var destination;
        if (schedule == null) {
          schedule = null;
        }
        if (schedule === null) {
          schedule = (function() {
            var j, ref, results;
            results = [];
            for (_ = j = 0, ref = BEATS_PER_MEASURE; 0 <= ref ? j < ref : j > ref; _ = 0 <= ref ? ++j : --j) {
              results.push(0);
            }
            return results;
          })();
        }
        destination = audioContext.createGain();
        destination.gain.value = 0.5;
        destination.connect(audioContext.destination);
        return samples[sampleName] = {
          buffer: buffer,
          schedule: schedule,
          destination: destination
        };
      },
      removeSample: function(sampleName) {
        return delete samples[sampleName];
      },
      renameSample: function(oldSampleName, newSampleName) {
        samples[newSampleName] = samples[oldSampleName];
        return delete samples[oldSampleName];
      },
      setScheduleForSample: function(sampleName, schedule) {
        return samples[sampleName].schedule = schedule;
      },
      setGainForSample: function(sampleName, gainValue) {
        return samples[sampleName].destination.gain.value = gainValue;
      },
      setBeatListener: function(listener) {
        return customBeatListener = listener;
      },
      start: function() {
        setInterval(doScheduling, MEASURE_DURATION * 1000 / 2);
        return isRunning = true;
      },
      isRunning: function() {
        return isRunning;
      },
      BEAT_DURATION: BEAT_DURATION,
      BEATS_PER_MEASURE: BEATS_PER_MEASURE
    };
    return Sequencer;
  });

}).call(this);
