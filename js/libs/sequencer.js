// Generated by CoffeeScript 1.9.2
(function() {
  var hasProp = {}.hasOwnProperty;

  define(['underscore'], function(_) {
    var CLOCKS_PER_MEASURE, CLOCK_LENGTH, MEASURE_LENGTH, Sequencer, audioContext, doScheduling, isRunning, samples;
    CLOCKS_PER_MEASURE = 16;
    MEASURE_LENGTH = 4;
    CLOCK_LENGTH = MEASURE_LENGTH / CLOCKS_PER_MEASURE;
    audioContext = new window.AudioContext();
    isRunning = false;
    samples = {};
    doScheduling = (function() {
      var nextMeasureStart;
      nextMeasureStart = audioContext.currentTime + MEASURE_LENGTH;
      return function() {
        var currentTime, i, isNote, j, len, name, node, ref, sample;
        currentTime = audioContext.currentTime;
        if (currentTime + MEASURE_LENGTH <= nextMeasureStart) {
          return;
        }
        for (name in samples) {
          if (!hasProp.call(samples, name)) continue;
          sample = samples[name];
          ref = sample.schedule;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            isNote = ref[i];
            if (isNote === 1) {
              node = audioContext.createBufferSource();
              node.buffer = sample.buffer;
              node.connect(audioContext.destination);
              node.start(nextMeasureStart + i * CLOCK_LENGTH);
            }
          }
        }
        return nextMeasureStart += MEASURE_LENGTH;
      };
    })();
    Sequencer = {
      addSample: function(sampleName, buffer, schedule) {
        if (schedule == null) {
          schedule = null;
        }
        if (schedule === null) {
          schedule = (function() {
            var j, ref, results;
            results = [];
            for (_ = j = 0, ref = CLOCKS_PER_MEASURE; 0 <= ref ? j <= ref : j >= ref; _ = 0 <= ref ? ++j : --j) {
              results.push(0);
            }
            return results;
          })();
        }
        return samples[sampleName] = {
          buffer: buffer,
          schedule: schedule
        };
      },
      setScheduleForSample: function(sampleName, schedule) {
        return samples[sampleName].schedule = schedule;
      },
      start: function() {
        setInterval(doScheduling, MEASURE_LENGTH * 1000 / 4);
        return isRunning = true;
      },
      isRunning: function() {
        return isRunning;
      },
      CLOCK_LENGTH: CLOCK_LENGTH,
      CLOCKS_PER_MEASURE: CLOCKS_PER_MEASURE
    };
    return Sequencer;
  });

}).call(this);
