// Generated by CoffeeScript 1.9.2
(function() {
  define([], function() {
    var BUFFER_LEN, NUM_CHANNELS, Recorder, audioCtx, flatten, getBuffers, initNewRecording, initRecorderAudioGraph, isRecording, isRecordingPossible, processorNode, recBuffers, recLength;
    BUFFER_LEN = 4096;
    NUM_CHANNELS = 2;
    isRecording = false;
    isRecordingPossible = false;
    recBuffers = null;
    recLength = 0;
    processorNode = null;
    audioCtx = new window.AudioContext();
    initNewRecording = function() {
      var i;
      recBuffers = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = NUM_CHANNELS; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push([]);
        }
        return results;
      })();
      return recLength = 0;
    };
    initRecorderAudioGraph = function(stream) {
      var input;
      input = audioCtx.createMediaStreamSource(stream);
      processorNode = audioCtx.createScriptProcessor(BUFFER_LEN, NUM_CHANNELS, NUM_CHANNELS);
      processorNode.onaudioprocess = function(e) {
        var buffer, channel, j, ref;
        if (isRecording) {
          buffer = [];
          for (channel = j = 0, ref = NUM_CHANNELS; 0 <= ref ? j < ref : j > ref; channel = 0 <= ref ? ++j : --j) {
            recBuffers[channel].push(new Float32Array(e.inputBuffer.getChannelData(channel)));
          }
          return recLength += e.inputBuffer.getChannelData(0).length;
        }
      };
      input.connect(processorNode);
      return processorNode.connect(audioCtx.destination);
    };
    flatten = function(buffers, bufferLength) {
      var b, j, len, offset, resBuffer;
      resBuffer = new Float32Array(bufferLength);
      offset = 0;
      for (j = 0, len = buffers.length; j < len; j++) {
        b = buffers[j];
        resBuffer.set(b, offset);
        offset += b.length;
      }
      return resBuffer;
    };
    getBuffers = function() {
      var buffers, channel, j, ref;
      buffers = [];
      for (channel = j = 0, ref = NUM_CHANNELS; 0 <= ref ? j < ref : j > ref; channel = 0 <= ref ? ++j : --j) {
        buffers.push(flatten(recBuffers[channel], recLength));
      }
      return buffers;
    };
    initNewRecording();
    Recorder = {
      getUserPermission: function(onSuccess) {
        return window.navigator.getUserMedia({
          audio: true
        }, (function(stream) {
          isRecordingPossible = true;
          initRecorderAudioGraph(stream);
          return onSuccess();
        }), (function(e) {
          console.log('Could not execute navigator.getUserMedia: ' + e);
          return isRecordingPossible = false;
        }));
      },
      startRecording: function() {
        if (!isRecordingPossible) {
          return false;
        }
        isRecording = true;
        return true;
      },
      stopRecording: function() {
        var buffers;
        if (!isRecordingPossible) {
          return false;
        }
        isRecording = false;
        buffers = getBuffers();
        initNewRecording();
        return buffers;
      },
      isReady: function() {
        return isRecordingPossible;
      }
    };
    return Recorder;
  });

}).call(this);
